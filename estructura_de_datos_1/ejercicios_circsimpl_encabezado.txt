EJERCICIOS DEL MODULO DE GARRIDO DE LISTAS CIRCULARES SIMPLES CON ENCABEZADO
1- Dada una lista circular, realizar un algoritmo que ordene la lista circular.
2- Realizar un algoritmo que inserte un nodo con informacion ELEM despues de la n-sima ocurrencia
   de un dato dentro de la lista circular llamado xinfo.
3- Dadas 3 listas circulares enlazadas y ordenadas. cree una lista circular con los nodos que aparecen en al menos dos de las 3 listas.
4- Un grupo de personas de pie forman un circulo y dado un N contar hasta el n-esimo nodo y eliminarlo hasta
   dejar una sola persona de pie(problema de josephus).
5- Considera la variacion del problema de josephus. Un grupo de personas de pie forman un circulo y cada uno elige un entero
   positivo. Se selecciona uno de los nombres y un entero positivo N. Empezando con la persona cuyo nombre se elige
   cuenta al rededor del circulo en sentido dextrogico y eliminan la n-esima persona despues, se elige
   el entero de esta persona a eliminar a la sgte persona a eliminar.
6- Escribe un programa para almacenar en una lista doblemente enlazada, el centesimo numero de la serie fibonacci.

DESARROLLO
1----------------------------------------------------------------------------------
-----en el main:
case 6:
   if(ptr == NULL)
   {
      cout << "la lista esta vacia" << endl;
      cin.get();
   }
   else if(ptr->sig->sig == ptr)
   {
      cout << "la lista solo tiene un elemento" << endl;
      cin.get();
   }
   else
   {
      int opt;
      system("clear");
      if(ptr == NULL)
      {
         cout << "Lista vacia" <<endl;
      }
      else
      {
         cout << "1- Ordenar Descendente\n2- Ordenar Ascendente" << endl;
         cout << "Ingrese una opcion: ";
         cin >> opt;
         switch(opt)
         {
            case 1:
            ptr = OrdenarDesc(ptr);
            break;
            case 2:
            ptr = OrdenarAsc(ptr);
            break;
            default:
            cout << "Valor invalido!" << endl;
            cin.get();
            break;
         }
      }
   }
   cin.ignore();
   break;
-----en la funcion:
/*para hacer ordenar ascendente solo cambiamos el < por > en el primer if de
*los ciclos anidados*/
Nodo *OrdenarDesc(Nodo *ptr)
{
   Nodo *p, *q, *aux, *aux2;
   p = ptr->sig;
   while(p != ptr)
   {
      q = ptr->sig;
      while(q != ptr)
      {
         /*para que no se produzca un inifity loop tenemos que dejar a q en
         ptr->ant con q->sig != ptr*/
         if(q->sig != ptr && q->info < q->sig->info)
         {
            aux = q->sig;
            if(q == ptr->sig)
            {
               q->sig = aux->sig;
               aux->sig = q;
               ptr->sig = aux;
            }
            else
            {
               if(aux->sig != ptr)
               {
                  aux2 = ptr->sig;
                  while(aux2->sig != q)
                  {
                     aux2 = aux2->sig;
                  }
                  q->sig = aux->sig;
                  aux->sig = q;
                  aux2->sig = aux;
               }
               else
               {
                  aux2 = ptr->sig;
                  while(aux2->sig != q)
                  {
                     aux2 = aux2->sig;
                  }
                  aux2->sig = aux;
                  q->sig = ptr;
                  aux->sig = q;
               }
            }
            /*en el caso de que rotemos un nodo y este tenga referenciado el bucle de recorrido
            principal, debemos regresar este a su posicion anterior para no afectar el funcionamiento de la funcion*/
            if(q == p)
            {
               p = aux;
            }
         }
         else
         {
            q = q->sig;
         }
      }
      p = p->sig;
   }
   cin.get();
   return ptr;
}
2----------------------------------------------------------------------------------
en el main:
case 8:
   system("clear");
   if(ptr == NULL)
   {
      cout << "La lista esta vacia." << endl;
      cin.ignore();
      cin.get();
   }
   else if(ptr->sig->sig == ptr)
   {
      cout << "La lista solo tiene un elemento." << endl;
      cin.ignore();
      cin.get();
   }
   else
   {
      InserOcurrencia(ptr);
   }
   break;
-----en la funcion:
Nodo *InserOcurrencia(Nodo *ptr)
{
   /*uso variables independientes para tener mejor manejo de la informacion y evitar ambiguedades*/
   int cont, cont2, info, ocu, info2;
   Nodo *aux, *aux2;
   Nodo *p = (struct Nodo*) malloc (sizeof(Nodo));
   aux = ptr->sig;
   /*solo esta disenado para cuando hay un solo elemento con ocurrencias*/
   while(aux != ptr)
   {
      info = aux->info;
      aux2 = ptr->sig;
      cont = 0;
      while(aux2 != ptr)
      {
         if(info == aux2->info)
         {
            cont++;
         }
         aux2 = aux2->sig;
      }
      if(cont > 1)
      {
         cout << "el elemento repetido es: " << info << " repetido " << cont << " veces."<< endl;
         break;
      }
      aux = aux->sig;
   }
   if(cont == 1)
   {
      cout << "No hay ocurrencias en la lista." << endl;
      cin.ignore();
      cin.get();
   }
   else
   {
      cout << "Despues de que ocurrencia desea ingresar el dato?: ";
      cin >> ocu;
      if(ocu >= 1 && ocu <= cont)
      {
         cont2 = ocu;
         cout << "Ingrese el dato del nodo: ";
         cin >> info2;
         p->info = info2;
         /*recorro la lista y disminuyo cont2 hasta 0 para indicar que la ocurrencia
         ha sido ubicada y procedemos a insertar*/
         while(aux->sig != ptr)
         {
            if(aux->info == info)
            {
               cont2--;
            }
            if(cont2 == 0)
            {
               break;
            }
            aux = aux->sig;
         }
         p->sig = aux->sig;
         aux->sig = p;
      }
      else
      {
         cout << "Ha ingresado un numero incorrecto" << endl;
         cin.ignore();
         cin.get();
      }
   }
}
3----------------------------------------------------------------------------------
