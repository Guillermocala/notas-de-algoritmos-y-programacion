EJERCICIOS DEL MODULO DE GARRIDO DE LISTAS CIRCULARES SIMPLES
1- Dada una lista circular simple hacer un algoritmo que elimine los nodos cuya informacion sea impar.
2- Dada una lista circular simple ordenada ascendentemente hacer un algoritmo que inserte un nodo con la informacion ELEM y la lista siga quedando ordenada.
3- Dada dos listas PTR1 y PTR2 hacer un algoritmo que una la lista 2 con la lista 1 teniendo encuenta lo sgte:
   a- Si el numero de nodos de la lista 1 es mayor al numero de nodos de la lista 2 se inserta la lista 2 al final de la lista 1.
   b- Si el numero de nodos de la lista 1 es menor al numero de nodos de la lista 2 se inserta la lista 1 al final de la lista 2.
   c- Si el numero de nodos de la lista 1 es igual al numero de nodos de la lista 2 se envia un mensaje al usuario diciendo que no se puede insertar.
4- Dada una lista circular simple hacer un algoritmo que saque la parte entera del promedio de los elementos de la lista y luego elimine los nodos cuya
   informacion sea menor a la parte entera del promedio.
5- Dada una lista simple y un nodo hacer un algoritmo que elimine el nodo de la posicion N, repita este procedimiento hasta que quede un solo
   nodo(problema de josephus) contando siempre el n-esimo nodo.
6- Dada dos listas circulares simples PTR1 y PTR2 hacer las sgtes operaciones:
   a- Union: Los elementos de PTR1 y PTR2 pasan a PTR3 sin repetirse.
   b- Intercepcion: Los elementos de PTR1 que esten en PTR2 pasan a PTR3.
   c- Diferencia PTR1-PTR2: Los elementos de PTR1 que no se encuentren en PTR2 pasan a PTR3.
7- Dada una lista circular simple hacer un algoritmo que busque un elemento ELEM e intercambie el nodo donde se encuentra ELEM con el primero.

   DESARROLLO
1---------------------------------------------------------------------------------
en el main:
case 8:
   system("clear");
   if(ptr == NULL)
   {
      cout << "Lista vacia" << endl;
      cin.ignore();
      cin.get();
   }
   else
   {
      ptr = ElimImpares(ptr);
   }
   break;
en la funcion:
Nodo *ElimImpares(Nodo *ptr)
{
   Nodo *aux = ptr;
   int elem;
   while(aux->sig != ptr)
   {
      if(aux->info %2 != 0)
      {
         elem = aux->info;
         ptr = EliminarNodo(ptr, elem);
         aux = aux->sig;
      }
      else
      {
         aux = aux->sig;
      }
   }
   if(aux->info %2 != 0)
   {
      elem = aux->info;
      ptr = EliminarNodo(ptr, elem);
   }
   return ptr;
}
2---------------------------------------------------------------------------------
en el main:
case 8:
   system("clear");
   cout << "Ingrese el dato: ";
   cin >> dato;
   ptr = InsertarAsc(ptr, dato);
   break;
en la funcion:
Nodo *InsertarAsc(Nodo *ptr, int xinfo)
{
   Nodo *p = (struct Nodo*) malloc (sizeof(Nodo));
   p->info = xinfo;
   if(ptr == NULL)
   {
      cout << "Lista vacia" << endl;
      cin.ignore();
      cin.get();
      }
   else
   {
      Nodo *aux = ptr, *aux2;
      while(aux->sig != ptr && xinfo > aux->info)
      {
         aux = aux->sig;
      }
      if(aux == ptr)
      {
         if(xinfo < aux->info)
         {
            aux2 = ptr;
            while(aux2->sig != aux)
            {
               aux2 = aux2->sig;
            }
            p->sig = ptr;
            aux2->sig = p;
            ptr = p;
         }
         else
         {
            p->sig = aux->sig;
            aux->sig = p;
         }
      }
      else
      {
         if(xinfo > aux->info)
         {
            aux->sig = p;
            p->sig = ptr;
         }
         else
         {
            aux2 = ptr;
            while(aux2->sig != aux)
            {
               aux2 = aux2->sig;
            }
            aux2->sig = p;
            p->sig = aux;
         }
      }
   }
   return ptr;
}
3---------------------------------------------------------------------------------
en el main:
case 8:
   system("clear");
   if(ptr == NULL || ptr2 == NULL)
   {
      if(ptr == NULL)
      {
         cout << "Lista 1 vacia..." << endl;
         cin.ignore();
         cin.get();
      }
      else
      {
         cout << "Lista 2 vacia..." << endl;
         cin.ignore();
         cin.get();
      }
   }
   else
   {
      UnirListas(ptr, ptr2);
   }
   break;
en la funcion:
Nodo *UnirListas(Nodo *ptr, Nodo *ptr2)
{
   Nodo *aux = ptr, *aux2 = ptr2;
   int cont1 = 1, cont2 = 1;
   while(aux->sig != ptr)
   {
      aux = aux->sig;
      cont1++;
   }
   while(aux2->sig != ptr2)
   {
      aux2 = aux2->sig;
      cont2++;
   }
   if(cont1 > cont2)
   {
      aux->sig = ptr2;
      aux2->sig = ptr;
   }
   else if(cont1 < cont2)
   {
      aux2->sig = ptr;
      aux->sig = ptr2;
   }
   else
   {
      cout << "No se puede efectuar la union..." << endl;
      cin.ignore();
      cin.get();
   }
}
4---------------------------------------------------------------------------------
en el main:
case 8:
   system("clear");
   ptr = PromedioElim(ptr);
   break;
en la funcion:
Nodo *PromedioElim(Nodo *ptr)
{
   int sum = 0, num = 1, elem, prom;
   Nodo *aux = ptr;
   while(aux->sig != ptr)
   {
      sum += aux->info;
      aux = aux->sig;
      num++;
   }
   sum += aux->info;
   prom = sum/num;
   aux = ptr;
   while(aux->sig != ptr)
   {
      if(aux->info < prom)
      {
         elem = aux->info;
         ptr = EliminarNodo(ptr, elem);
         aux = aux->sig;
      }
      else
      {
         aux = aux->sig;
      }
   }
   if(aux->info < prom)
   {
      elem = aux->info;
      ptr = EliminarNodo(ptr, elem);
   }
   return ptr;
}
5---------------------------------------------------------------------------------
en el main:
case 8:
   system("clear");
   int elem;
   if(ptr == NULL)
   {
      cout << "Lista vacia..." << endl;
   }
   else
   {
      cout << "Ingrese el nodo a eliminar: ";
      cin >> elem;
      ptr = Josephus(ptr, elem);
   }
   break;
en la funcion:
Nodo *Josephus(Nodo *ptr, int elem)
{
   Nodo *aux = Buscar(ptr, elem);
   int num;
   if(aux == NULL)
   {
      cout << "Elemento no se puede eliminar" << endl;
      cin.ignore();
      cin.get();
   }
   else
   {
      while(ptr->sig != ptr)
      {
         num = aux->info;
         ptr = EliminarNodo(ptr, num);
         for(int i = 1; i < num; i++)
         {
            aux = aux->sig;
         }
         aux = aux->sig;
      }
   }
   return ptr;
}
7---------------------------------------------------------------------------------
en el main:
case 8:
   int opt, dato2;
   system("clear");
   cout << "Se intercambiara el nodo del dato ingresado con el primero nodo" << endl;
   cout << "Ingrese 1 para continuar u otro numero para ir al menu anterior: ";
   cin >> opt;
   if(opt == 1)
   {
      cout << "Ingrese el dato a buscar: ";
      cin >> dato2;
      ptr = intercambio(ptr, dato2);
   }
   else
   {
      /*unexpected function*/
   }
   break;
en la funcion:
Nodo *intercambio(Nodo *ptr, int elem)
{
   Nodo *q = Buscar(ptr, elem);
   if(q == NULL)
   {
      cout << "No se encontro el elemento" << endl;
      cin.ignore();
      cin.get();
   }
   else if(ptr->sig == ptr)
   {
      cout << "solo hay un elemento en la lista" << endl;
      cin.ignore();
      cin.get();
   }
   else if(q == ptr)
   {
      cout << "el elemento ya esta en el primer nodo" << endl;
      cin.ignore();
      cin.get();
   }
   else
   {
      Nodo *aux, *aux2;
      /*para cuando solo hay dos elem en la lista*/
      if(ptr->sig->sig == ptr && q->sig == ptr)
      {
         ptr = ptr->sig;
      }
      else if(q->sig == ptr)
      {
         aux = ptr;
         while(aux->sig != q)
         {
            aux = aux->sig;
         }
         q->sig = ptr->sig;
         aux->sig = ptr;
         ptr->sig = q;
         ptr = q;
      }
      else
      {
         /*se posicionan dos aux antes de cada parte, luego se crean mini listas SIMPLES
         y despues se mueven los aux para terminar de conectar la lista como si fuese una sola*/
         aux = ptr;
         while(aux->sig != ptr)
         {
            aux = aux->sig;
         }
         aux2 = ptr;
         while(aux2->sig != q)
         {
            aux2 = aux2->sig;
         }
         aux2->sig = ptr;
         aux->sig = q;
         aux2 = ptr->sig;
         aux = q->sig;
         q->sig = aux2;
         ptr->sig = aux;
         ptr = q;
      }
   }
   return ptr;
}
